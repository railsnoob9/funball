<html>
  <head>      
    <script language="javascript" src="processing.js"></script>

  </head>
  
  <body>
	<div>
		<center>
			<canvas id ="world"></canvas>
		</center>
    </div>   
       <script>
var sketch = new Processing.Sketch();
var sizeOfCanvasX = 800;
var sizeOfCanvasY = 600;

var background = {
	color: {
		r: 155,
		g: 155,
		b: 155
	},
	size: {
		x: 800,
		y: 600
	}
};

var player = {
	position: {
		x: 400,
		y: 120
	},
	speed: {
		acceleration: .03,
		//entropy: 0.005,
		entropy:0,
		max: 3,
		min: -3,
		current: {
			x: 0,
			y: 0
		}
	},
	size: {
		x: 50,
		y: 50
	},
	color: {
		r: 0,
		g: 25,
		b: 255
	}
};

var player2 = {
	position: {
		x: 400,
		y: 240
	},
	speed: {
		acceleration: .2,
		//entropy: 0.005,
		entropy:0,
		max: 4,
		min: -4,
		current: {
			x: 0,
			y: 0
		}
	},
	size: {
		x: 50,
		y: 50
	},
	color: {
		r: 255,
		g: 25,
		b: 0
	}
};

var gamespace = {
	position: {
		x: sizeOfCanvasX/2,
		y: sizeOfCanvasY/2
	},
	size:{
		width: sizeOfCanvasX/1.6,
		//height: sizeOfCanvasY/1.1
		height:sizeOfCanvasX/1.6
	},
	gamespaceBackgroundRandom: 0,
	colorIfSolid:{
		r: 40,
		g: 40,
		b: 50
	}
};

var isoutside;
var iscollision;


var num = player.size.x*2;
var mx = new Array();
var my = new Array();

var keys = { /*up*/38:0, /*down*/40:0, /*left*/37:0, /*right*/39:0 };
  document.addEventListener('keydown', function(e) {
    if(e.keyCode in keys) {
      keys[e.keyCode] = 1;
    }
  }, false);

  document.addEventListener('keyup', function(e) {
    if(e.keyCode in keys) {
      keys[e.keyCode] = 0;
    }
  }, false);


sketch.attachFunction = function(processing) {
	// happens when page loads
	processing.setup = function() {
		processing.size(sizeOfCanvasX, sizeOfCanvasY);
		processing.background(background.color.r,background.color.g,background.color.b);	  
	};
	// happens every frame
	processing.draw = function() {

		// set fill color allows us to on the fly determine if we want a random background or not
		if (gamespace.gamespaceBackgroundRandom == 1)
		{
			processing.fill(processing.random(255),processing.sin(processing.noise()),50);
		}
		else
		{
			processing.fill(gamespace.colorIfSolid.r,gamespace.colorIfSolid.g,gamespace.colorIfSolid.b);
		}
		
		// draw an ellipse--outer (gamespace)	
		//make it get a bit smaller each frame	
		gamespace.size.width = gamespace.size.width-.05;
		gamespace.size.height = gamespace.size.height-.05;		
		processing.ellipse(gamespace.position.x,gamespace.position.y,gamespace.size.width,gamespace.size.height);
		
		// set stroke color
		processing.stroke(background.color.r,background.color.g,background.color.b);
		// set fill color
		processing.fill(player.color.r,player.color.g,player.color.b);
		// check keyboard input
		if (
			keys[37] == 1 ||
			keys[38] == 1 ||
			keys[39] == 1 ||
			keys[40] == 1
			)
		{
			// set the fill color to background color (shadow effect)
			processing.fill(background.color.r,background.color.g,background.color.b);
			// draw an ellipse (player starting point)
			processing.ellipse(player.position.x,player.position.y,player.size.x,player.size.y);	
			
			// update speed of player
			if (keys[37]==1)
			{
				player.speed.current.x = player.speed.current.x - player.speed.acceleration;
			}
			if (keys[38]==1)
			{
				//ellipsey = ellipsey - speedacceleration;
				player.speed.current.y = player.speed.current.y - player.speed.acceleration;				
			}
			if (keys[39]==1)
			{
				//ellipsex = ellipsex + speedacceleration;
				player.speed.current.x = player.speed.current.x + player.speed.acceleration;
			}
			if (keys[40]==1)
			{
				//ellipsey = ellipsey + speedacceleration;
				player.speed.current.y = player.speed.current.y + player.speed.acceleration;					
			}

		}
		// apply entropy/friction
		if (player.speed.current.x > 0) {
			player.speed.current.x = player.speed.current.x - player.speed.entropy;
		} else if (player.speed.current.x < 0) {
			player.speed.current.x = player.speed.current.x + player.speed.entropy;
		}
		if (player.speed.current.y > 0) {
			player.speed.current.y = player.speed.current.y - player.speed.entropy;
		} else if (player.speed.current.y < 0) {
			player.speed.current.y = player.speed.current.y + player.speed.entropy;
		}
		
		// constrain speed
		if (player.speed.current.y > player.speed.max) { player.speed.current.y = player.speed.max; }
		if (player.speed.current.x > player.speed.max) { player.speed.current.x = player.speed.max; }
		if (player.speed.current.y < player.speed.min) { player.speed.current.y = player.speed.min; }
		if (player.speed.current.x < player.speed.min) { player.speed.current.x = player.speed.min; }	
		// contrain position
		if (player.position.x < 0) { player.speed.current.x = -player.speed.current.x; }
		if (player.position.y < 0) { player.speed.current.y = -player.speed.current.y; }
		if (player.position.x > background.size.x) { player.speed.current.x = -player.speed.current.x; }
		if (player.position.y > background.size.y) { player.speed.current.y = -player.speed.current.y; }

		//check if players collided
		iscollision = playerEdgeDetect();

		if (iscollision ==1)
		{
			player.speed.current.x = -player.speed.current.x;
			player.speed.current.y = -player.speed.current.y;
		}

		// update position of player
		player.position.x = player.position.x + player.speed.current.x;	
		player.position.y = player.position.y + player.speed.current.y;				
	
		// define local scope function
		function outerCircleEdgeDetect()
		{
			var distancex = player.position.x - gamespace.position.x;
			var distancey = player.position.y - gamespace.position.y;
			
			var totaldistance = processing.sqrt(distancex*distancex + distancey*distancey);
			
			//we know it's a circle, so can just use radius
			var radius = gamespace.size.width/2;
			
			if (totaldistance > radius)
				return 1;
			else
				return 0;
		};	

		// define local scope function
		//way too simple right now
		function playerEdgeDetect()
		{
			var distancex = player.position.x - player2.position.x;
			var distancey = player.position.y - player2.position.y;
			
			var totaldistance = processing.sqrt(distancex*distancex + distancey*distancey);
			
			//we know it's a circle, so can just use radius
			//this also assumes that the two players are the same size 
			var radius = player.size.x;
			
			if (totaldistance <= radius)
				return 1;
			else
				return 0;
		};	


	    // Reads throught the entire array
	    // and shifts the values to the left

	    for(var i=1; i<num; i++) {

			mx[i-1] = mx[i];
	 		my[i-1] = my[i];

	    } 
	    	mx[num-1] = player.position.x;
  			my[num-1] = player.position.y;

						
		// set the fill color (player color)
		processing.fill(player.color.r,player.color.g,player.color.b);
		// draw the player ellipse
	//	processing.ellipse(player.position.x,player.position.y,player.size.x,player.size.y);

		for(var i=0; i<num; i++) {

    		processing.ellipse(mx[i], my[i], i/2, i/2);

  		}
		
		// set the fill color (player2 color)
		processing.fill(player2.color.r,player2.color.g,player2.color.b);
		// draw the player ellipse
		processing.ellipse(player2.position.x,player2.position.y,player2.size.x,player2.size.y);
  
		isoutside = outerCircleEdgeDetect();

  		if (isoutside ==1)
		{
		// processing.textAlign(processing.CENTER,processing.BOTTOM);
		// processing.textFont(processing.createFont("Arial", 24));	   
			//losing text
			processing.textSize(40);
			processing.fill(255,255,255);
			processing.text("Red Wins", sizeOfCanvasX/2-100, 200,550,550);
			
		}

	};  
};
	  
var canvas = document.getElementById("world");
// attaching the sketch to the canvas
var p = new Processing(canvas, sketch);
  
function draw() {
    window.requestAnimationFrame(draw);
}
		</script>
	</body>
</html>
<html>
  <head>      
    <script language="javascript" src="processing.js"></script>

  </head>
  
  <body>
	<div>
		<center>
			<canvas id ="world"></canvas>
		</center>
    </div>   
       <script>
var sketch = new Processing.Sketch();
var sizeOfCanvasX = 800;
var sizeOfCanvasY = 600;
var isGameOver = 0;
var frameRate = 240;
//var globalCounter = 0;

var globalAccel = .0173;
//var globalAccel = 10;
var globalMax = 100;
var globalMin = -100;

var background = {
	color: {
		r: 155,
		g: 155,
		b: 155
	},
	size: {
		x: sizeOfCanvasX,
		y: sizeOfCanvasY
	}
};

var player = {
	tail: {
		tailmx: new Array(),
		tailmy: new Array()
	},
	position: {
		x: 400,
		y: 120
	},
	speed: {
		acceleration: globalAccel,
		//entropy: 0.005,
		entropy:0,
		max: globalMax,
		min: globalMin,
		current: {
			x: 0,
			y: 0
		}
	},
	size: {
		x: 50,
		y: 50,
		mass: 1
	},
	color: {
		r: 0,
		g: 25,
		b: 255
	}
};

var player2 = {
	tail: {
		tailmx: new Array(),
		tailmy: new Array()
	},
	position: {
		x: 400,
		y: 440
	},
	speed: {
		acceleration: globalAccel,
		//entropy: 0.005,
		entropy:0,
		max: globalMax,
		min: globalMin,
		current: {
			x: 0,
			y: 0
		}
	},
	size: {
		x: 50,
		y: 50,
		mass: 1
	},
	color: {
		r: 255,
		g: 25,
		b: 0
	}
};

var gamespace = {
	position: {
		x: sizeOfCanvasX/2,
		y: sizeOfCanvasY/2
	},
	size:{
		width: sizeOfCanvasX/1.6,
		//height: sizeOfCanvasY/1.1
		height:sizeOfCanvasX/1.6
	},
	gamespaceBackgroundRandom: 0,
	colorIfSolid:{
		r: 40,
		g: 40,
		b: 50
	}
};

var isoutside;
var isoutside2;
var iscollision;

//for tail


var keys = { /*up*/38:0, /*down*/40:0, /*left*/37:0, /*right*/39:0 };
  document.addEventListener('keydown', function(e) {
    if(e.keyCode in keys) {
      keys[e.keyCode] = 1;
    }
  }, false);

  document.addEventListener('keyup', function(e) {
    if(e.keyCode in keys) {
      keys[e.keyCode] = 0;
    }
  }, false);

  var keys2 = { /*up--w*/87:0, /*down--s*/83:0, /*left--a*/65:0, /*right--d*/68:0 };
  document.addEventListener('keydown', function(e) {
    if(e.keyCode in keys2) {
      keys2[e.keyCode] = 1;
    }
  }, false);

  document.addEventListener('keyup', function(e) {
    if(e.keyCode in keys2) {
      keys2[e.keyCode] = 0;
    }
  }, false);


sketch.attachFunction = function(processing) {
	// happens when page loads
	processing.setup = function() {
		processing.size(sizeOfCanvasX, sizeOfCanvasY);
		processing.background(background.color.r,background.color.g,background.color.b);	  
		processing.frameRate(frameRate); 
	};
	// happens every frame
	processing.draw = function() {

		// set fill color allows us to on the fly determine if we want a random background or not
		if (gamespace.gamespaceBackgroundRandom == 1)
		{
			processing.fill(processing.random(255),processing.sin(processing.noise()),50);
		}
		else
		{
			processing.fill(gamespace.colorIfSolid.r,gamespace.colorIfSolid.g,gamespace.colorIfSolid.b);
		}
		
		// draw an ellipse--outer (gamespace)	
		//make it get a bit smaller each frame	
		gamespace.size.width = gamespace.size.width-.05;
		gamespace.size.height = gamespace.size.height-.05;		
		processing.ellipse(gamespace.position.x,gamespace.position.y,gamespace.size.width,gamespace.size.height);
		
		// set stroke color
		processing.stroke(background.color.r,background.color.g,background.color.b);
		//processing.noStroke();
		// set fill color
		processing.fill(player.color.r,player.color.g,player.color.b);
		// check keyboard input
		if (
			keys[37] == 1 ||
			keys[38] == 1 ||
			keys[39] == 1 ||
			keys[40] == 1
			)
		{
			// set the fill color to background color (shadow effect)
			processing.fill(background.color.r,background.color.g,background.color.b);
			// draw an ellipse (player starting point)
			processing.ellipse(player.position.x,player.position.y,player.size.x,player.size.y);	
			
			// update speed of player
			if (keys[37]==1)
			{
				player.speed.current.x = player.speed.current.x - player.speed.acceleration;
			}
			if (keys[38]==1)
			{
				//ellipsey = ellipsey - speedacceleration;
				player.speed.current.y = player.speed.current.y - player.speed.acceleration;				
			}
			if (keys[39]==1)
			{
				//ellipsex = ellipsex + speedacceleration;
				player.speed.current.x = player.speed.current.x + player.speed.acceleration;
			}
			if (keys[40]==1)
			{
				//ellipsey = ellipsey + speedacceleration;
				player.speed.current.y = player.speed.current.y + player.speed.acceleration;					
			}

		}

		//player2
		if (
			keys2[87] == 1 ||
			keys2[83] == 1 ||
			keys2[65] == 1 ||
			keys2[68] == 1
			)
		{
			// set the fill color to background color (shadow effect)
			//processing.fill(background.color.r,background.color.g,background.color.b);
			// draw an ellipse (player starting point)
			//processing.ellipse(player2.position.x,player2.position.y,player2.size.x,player2.size.y);	
			
			// update speed of player
			if (keys2[65]==1)
			{
				player2.speed.current.x = player2.speed.current.x - player2.speed.acceleration;
			}
			if (keys2[87]==1)
			{
				//ellipsey = ellipsey - speedacceleration;
				player2.speed.current.y = player2.speed.current.y - player2.speed.acceleration;				
			}
			if (keys2[68]==1)
			{
				//ellipsex = ellipsex + speedacceleration;
				player2.speed.current.x = player2.speed.current.x + player2.speed.acceleration;
			}
			if (keys2[83]==1)
			{
				//ellipsey = ellipsey + speedacceleration;
				player2.speed.current.y = player2.speed.current.y + player2.speed.acceleration;					
			}

		}
		// apply entropy/friction
		if (player.speed.current.x > 0) {
			player.speed.current.x = player.speed.current.x - player.speed.entropy;
		} else if (player.speed.current.x < 0) {
			player.speed.current.x = player.speed.current.x + player.speed.entropy;
		}
		if (player.speed.current.y > 0) {
			player.speed.current.y = player.speed.current.y - player.speed.entropy;
		} else if (player.speed.current.y < 0) {
			player.speed.current.y = player.speed.current.y + player.speed.entropy;
		}
		
		// constrain speed
		if (player.speed.current.y > player.speed.max) { player.speed.current.y = player.speed.max; }
		if (player.speed.current.x > player.speed.max) { player.speed.current.x = player.speed.max; }
		if (player.speed.current.y < player.speed.min) { player.speed.current.y = player.speed.min; }
		if (player.speed.current.x < player.speed.min) { player.speed.current.x = player.speed.min; }	

		//player2
		if (player2.speed.current.y > player2.speed.max) { player2.speed.current.y = player2.speed.max; }
		if (player2.speed.current.x > player2.speed.max) { player2.speed.current.x = player2.speed.max; }
		if (player2.speed.current.y < player2.speed.min) { player2.speed.current.y = player2.speed.min; }
		if (player2.speed.current.x < player2.speed.min) { player2.speed.current.x = player2.speed.min; }	
		// contrain position
		if (player.position.x < 0) { player.speed.current.x = -player.speed.current.x; }
		if (player.position.y < 0) { player.speed.current.y = -player.speed.current.y; }
		if (player.position.x > background.size.x) { player.speed.current.x = -player.speed.current.x; }
		if (player.position.y > background.size.y) { player.speed.current.y = -player.speed.current.y; }
		//player2
		if (player2.position.x < 0) { player2.speed.current.x = -player2.speed.current.x; }
		if (player2.position.y < 0) { player2.speed.current.y = -player2.speed.current.y; }
		if (player2.position.x > background.size.x) { player2.speed.current.x = -player2.speed.current.x; }
		if (player2.position.y > background.size.y) { player2.speed.current.y = -player2.speed.current.y; }

		handleCollision();

		function handleCollision()
		{
			//check if players collided
			iscollision = playerEdgeDetect();

			if (iscollision ==1)
			{
				//2d elastic collision
				var distancex = player.position.x - player2.position.x;
				var distancey = player.position.y - player2.position.y;

				var collisionision_angle = processing.atan2(distancey, distancex);


				var magnitude_1 = processing.sqrt(player.speed.current.x*player.speed.current.x+player.speed.current.y*player.speed.current.y);
				var magnitude_2 = processing.sqrt(player2.speed.current.x*player2.speed.current.x+player2.speed.current.y*player2.speed.current.y);
				var direction_1 = processing.atan2(player.speed.current.y, player.speed.current.x);
				var direction_2 = processing.atan2(player2.speed.current.y, player2.speed.current.x);

				var new_xspeed_1 = magnitude_1*processing.cos(direction_1-collisionision_angle);
				var new_yspeed_1 = magnitude_1*processing.sin(direction_1-collisionision_angle);
				var new_xspeed_2 = magnitude_2*processing.cos(direction_2-collisionision_angle);
				var new_yspeed_2 = magnitude_2*processing.sin(direction_2-collisionision_angle);


				var final_xspeed_1 = ((player.size.mass-player2.size.mass)*new_xspeed_1+(player2.size.mass+player2.size.mass)*new_xspeed_2)/
					(player.size.mass+player2.size.mass);
				var final_xspeed_2 = ((player.size.mass+player.size.mass)*new_xspeed_1+(player.size.mass-player2.size.mass)*new_xspeed_2)/
					(player.size.mass+player2.size.mass);
				var final_yspeed_1 = new_yspeed_1;
				var final_yspeed_2 = new_yspeed_2;

				player.speed.current.x = processing.cos(collisionision_angle)*final_xspeed_1+processing.cos(collisionision_angle+processing.PI/2)*final_yspeed_1;
				player.speed.current.y = processing.sin(collisionision_angle)*final_xspeed_1+processing.sin(collisionision_angle+processing.PI/2)*final_yspeed_1;
				player2.speed.current.x = processing.cos(collisionision_angle)*final_xspeed_2+processing.cos(collisionision_angle+processing.PI/2)*final_yspeed_2;
				player2.speed.current.y = processing.sin(collisionision_angle)*final_xspeed_2+processing.sin(collisionision_angle+processing.PI/2)*final_yspeed_2;
			}
		}


		// update position of player
		player.position.x = player.position.x + player.speed.current.x;	
		player.position.y = player.position.y + player.speed.current.y;	

		player2.position.x = player2.position.x + player2.speed.current.x;	
		player2.position.y = player2.position.y + player2.speed.current.y;				
	
		// define local scope function
		function outerCircleEdgeDetect(x, y)
		{
			var distancex = x - gamespace.position.x;
			var distancey = y - gamespace.position.y;
			
			var totaldistance = processing.sqrt(distancex*distancex + distancey*distancey);
			
			//we know it's a circle, so can just use radius
			var radius = gamespace.size.width/2;
			
			if (totaldistance > radius)
				return 1;
			else
				return 0;
		};	

		// define local scope function
		//way too simple right now
		function playerEdgeDetect()
		{
			var distancex = player.position.x - player2.position.x;
			var distancey = player.position.y - player2.position.y;
			
			var totaldistance = processing.sqrt(distancex*distancex + distancey*distancey);
			
			//we know it's a circle, so can just use radius
			//this also assumes that the two players are the same size 
			var radius = player.size.x;
			
			if (totaldistance <= radius)
				return 1;
			else
				return 0;
		};	


		//tail stuff

	    // Reads throught the entire array
	    // and shifts the values to the left
	    for(var i=1; i<player.size.x; i++) {
			player.tail.tailmx[i-1] = player.tail.tailmx[i];
	 		player.tail.tailmy[i-1] = player.tail.tailmy[i];
	    } 
	    for(var i=1; i<player2.size.x; i++) {
			player2.tail.tailmx[i-1] = player2.tail.tailmx[i];
	 		player2.tail.tailmy[i-1] = player2.tail.tailmy[i];
	    } 

	    player.tail.tailmx[player.size.x-1] = player.position.x;
  		player.tail.tailmy[player.size.x-1] = player.position.y;
  		player2.tail.tailmx[player2.size.x-1] = player2.position.x;
  		player2.tail.tailmy[player2.size.x-1] = player2.position.y;

						
		// set the fill color (player color)
		processing.fill(player.color.r,player.color.g,player.color.b);
		// draw the player ellipse

	//	var playerColor= processing.color(player.color.r,player.color.g,player.color.b);

	//	processing.fill(playerColor,15);
		//draw tails
		for(var i=0; i<player.size.x; i++) {
    		processing.ellipse(player.tail.tailmx[i], player.tail.tailmy[i], i, i);
  		}
		
		// set the fill color (player2 color)
		processing.fill(player2.color.r,player2.color.g,player2.color.b);
		// draw the player ellipse
		processing.ellipse(player2.position.x,player2.position.y,player2.size.x,player2.size.y);

		for(var i=0; i<player2.size.x; i++) {
    		processing.ellipse(player2.tail.tailmx[i], player2.tail.tailmy[i], i, i);
  		}
  
		isoutside = outerCircleEdgeDetect(player.position.x, player.position.y);
		isoutside2 = outerCircleEdgeDetect(player2.position.x, player2.position.y);

		//end of game texts
  		if (isoutside ==1 && isoutside2 ==0)
		{
			processing.textSize(40);
			processing.fill(255,255,255);
			processing.text("Red Wins", sizeOfCanvasX/2-100, 200,550,550);
			isGameOver = 1;
		}
		if (isoutside ==0 && isoutside2 ==1)
		{
			processing.textSize(40);
			processing.fill(255,255,255);
			processing.text("Blue Wins", sizeOfCanvasX/2-100, 200,550,550);
			isGameOver = 1;
		}
		if (isoutside ==1 && isoutside2 ==1)
		{
			processing.textSize(40);
			processing.fill(255,255,255);
			processing.text("Draw", sizeOfCanvasX/2-100, 200,550,550);
			isGameOver = 1;
		}

		// if (isGameOver ==1)
		// {
		// 	player.speed.current.x = player.speed.current.x / 20;
		// 	player.speed.current.y = player.speed.current.y / 20;

		// 	player2.speed.current.x = player2.speed.current.x / 20;
		// 	player2.speed.current.y = player2.speed.current.y / 20;
		// }



	};  
};
	  
var canvas = document.getElementById("world");
// attaching the sketch to the canvas
var p = new Processing(canvas, sketch);
  
function draw() {
    window.requestAnimationFrame(draw);
}
		</script>
	</body>
</html>